/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/buffered_struct.cpp:22:21: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_block1 = std::unique_ptr(new block_t(m__io__raw_block1, this, m__root));
               ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/buffered_struct.cpp:26:21: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_block2 = std::unique_ptr(new block_t(m__io__raw_block2, this, m__root));
               ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imported_and_rel.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new imported_root_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^

2 errors generated.
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/buffered_struct.cpp.o] Error 1
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imported_and_rel.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_eos_struct.cpp:20:48: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_chunks->push_back(std::move(std::unique_ptr(new chunk_t(m__io, this, m__root))));
                                          ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/instance_user_array.cpp:67:54: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_user_entries->push_back(std::move(std::unique_ptr(new entry_t(io__raw_user_entries, this, m__root))));
                                                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_eos_struct.cpp.o] Error 1
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/instance_user_array.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_false2.cpp:16:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_parentless = std::unique_ptr(new child_t(m__io, nullptr, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_false2.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_call_short.cpp:17:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_buf1 = std::unique_ptr(new my_str1_t(5, m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_call_short.cpp:18:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_buf2 = std::unique_ptr(new my_str2_t((2 + 3), true, m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_2.cpp:24:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_str1 = std::unique_ptr(new mod_str_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_2.cpp:25:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_str2 = std::unique_ptr(new mod_str_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_2.cpp:48:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_rest = std::unique_ptr(new tuple_t(m__io__raw_rest, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_2.cpp:83:21: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_tuple5 = std::unique_ptr(new tuple_t(m__io, this, m__root));
               ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_call_short.cpp.o] Error 1
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_2.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_root.cpp:17:21: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_header = std::unique_ptr(new header_obj_t(m__io, this, m__root));
               ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_root.cpp:18:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_index = std::unique_ptr(new index_obj_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_root.cpp:51:45: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_entries->push_back(std::move(std::unique_ptr(new entry_t(m__io, this, m__root))));
                                       ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_root.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_external_type_02_parent.cpp:17:21: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_parent = std::unique_ptr(new parent_obj_t(m__io, this, m__root));
               ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_external_type_02_parent.cpp:31:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_child = std::unique_ptr(new opaque_external_type_02_child_t(m__io));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name2.cpp:18:24: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_main_data = std::unique_ptr(new main_t(m__io, this, m__root));
                  ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name2.cpp:19:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_dummy = std::unique_ptr(new dummy_obj_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name2.cpp:34:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_foo = std::unique_ptr(new foo_obj_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name2.cpp:62:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_foo = std::unique_ptr(new foo_obj_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_external_type_02_parent.cpp.o] Error 1
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name2.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_is_le.cpp:21:46: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_docs->push_back(std::move(std::unique_ptr(new doc_t(m__io, this, m__root))));
                                        ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_is_le.cpp:39:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_main = std::unique_ptr(new main_obj_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_is_le.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/bcd_user_type_le.cpp:23:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_ltr = std::unique_ptr(new ltr_obj_t(m__io__raw_ltr, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/bcd_user_type_le.cpp:26:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_rtl = std::unique_ptr(new rtl_obj_t(m__io__raw_rtl, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/bcd_user_type_le.cpp:29:31: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_leading_zero_ltr = std::unique_ptr(new leading_zero_ltr_obj_t(m__io__raw_leading_zero_ltr, this, m__root));
                         ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/bcd_user_type_le.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.cpp:17:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_first = std::unique_ptr(new block_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_one = std::unique_ptr(new struct_type_t(first(), m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.cpp:18:33: error: no matching constructor for initialization of 'params_pass_struct_t::struct_type_t'
    m_one = std::unique_ptr(new struct_type_t(first(), m__io, this, m__root));
                                ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.h:56:9: note: candidate constructor not viable: no known conversion from 'params_pass_struct_t::block_t *' to 'std::unique_ptr<kaitai::kstruct>' for 1st argument
        struct_type_t(std::unique_ptr<kaitai::kstruct> p_foo, kaitai::kstream* p__io, params_pass_struct_t* p__parent = nullptr, params_pass_struct_t* p__root = nullptr);
        ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.h:51:11: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 4 were provided
    class struct_type_t : public kaitai::kstruct {
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.cpp:40:11: error: overload resolution selected deleted operator '='
    m_foo = p_foo;
    ~~~~~ ^ ~~~~~
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:274:19: note: candidate function has been explicitly deleted
      unique_ptr& operator=(const unique_ptr&) = delete;
                  ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:190:7: note: candidate function not viable: no known conversion from 'std::unique_ptr<kaitai::kstruct>' to 'std::unique_ptr<kaitai::kstruct, std::default_delete<kaitai::kstruct> > &&' for 1st argument
      operator=(unique_ptr&& __u) noexcept
      ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:203:2: note: candidate function [with _Up = kaitai::kstruct, _Ep = std::default_delete<kaitai::kstruct>] not viable: no known conversion from 'std::unique_ptr<kaitai::kstruct>' to 'unique_ptr<kaitai::kstruct, std::default_delete<kaitai::kstruct> > &&' for 1st argument
        operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
        ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:211:7: note: candidate function not viable: no known conversion from 'std::unique_ptr<kaitai::kstruct>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.cpp:46:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_bar = std::unique_ptr(new baz_t(foo(), m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.cpp:46:33: error: no matching constructor for initialization of 'params_pass_struct_t::struct_type_t::baz_t'
    m_bar = std::unique_ptr(new baz_t(foo(), m__io, this, m__root));
                                ^     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.h:68:13: note: candidate constructor not viable: no known conversion from 'kaitai::kstruct *' to 'std::unique_ptr<kaitai::kstruct>' for 1st argument
            baz_t(std::unique_ptr<kaitai::kstruct> p_foo, kaitai::kstream* p__io, params_pass_struct_t::struct_type_t* p__parent = nullptr, params_pass_struct_t* p__root = nullptr);
            ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.h:64:15: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 4 were provided
        class baz_t : public kaitai::kstruct {
              ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.cpp:55:11: error: overload resolution selected deleted operator '='
    m_foo = p_foo;
    ~~~~~ ^ ~~~~~
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:274:19: note: candidate function has been explicitly deleted
      unique_ptr& operator=(const unique_ptr&) = delete;
                  ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:190:7: note: candidate function not viable: no known conversion from 'std::unique_ptr<kaitai::kstruct>' to 'std::unique_ptr<kaitai::kstruct, std::default_delete<kaitai::kstruct> > &&' for 1st argument
      operator=(unique_ptr&& __u) noexcept
      ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:203:2: note: candidate function [with _Up = kaitai::kstruct, _Ep = std::default_delete<kaitai::kstruct>] not viable: no known conversion from 'std::unique_ptr<kaitai::kstruct>' to 'unique_ptr<kaitai::kstruct, std::default_delete<kaitai::kstruct> > &&' for 1st argument
        operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
        ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:211:7: note: candidate function not viable: no known conversion from 'std::unique_ptr<kaitai::kstruct>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
7 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_struct.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_eos.cpp:20:48: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_chunks->push_back(std::move(std::unique_ptr(new chunk_t(m__io, this, m__root))));
                                          ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_eos.cpp:42:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_body = std::unique_ptr(new chunk_body_t(m__io__raw_body, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_eos.cpp:63:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new chunk_meta_t(m__io__raw_body, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_eos.cpp:70:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new chunk_dir_t(m__io__raw_body, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_eos.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_n_struct.cpp:21:44: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_chunks->push_back(std::move(std::unique_ptr(new chunk_t(m__io, this, m__root))));
                                      ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_n_struct.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/multiple_use.cpp:17:17: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_t1 = std::unique_ptr(new type_1_t(m__io, this, m__root));
           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/multiple_use.cpp:18:17: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_t2 = std::unique_ptr(new type_2_t(m__io, this, m__root));
           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/multiple_use.cpp:45:24: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_first_use = std::unique_ptr(new multi_t(m__io, this, m__root));
                  ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/multiple_use.cpp:72:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_second_use = std::unique_ptr(new multi_t(m__io, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/multiple_use.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/bcd_user_type_be.cpp:23:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_ltr = std::unique_ptr(new ltr_obj_t(m__io__raw_ltr, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/bcd_user_type_be.cpp:26:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_rtl = std::unique_ptr(new rtl_obj_t(m__io__raw_rtl, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/bcd_user_type_be.cpp:29:31: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_leading_zero_ltr = std::unique_ptr(new leading_zero_ltr_obj_t(m__io__raw_leading_zero_ltr, this, m__root));
                         ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_mod.cpp:16:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_main = std::unique_ptr(new main_obj_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_mod.cpp:32:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_nest = std::unique_ptr(new subnest_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_mod.cpp:33:22: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_nest_be = std::unique_ptr(new subnest_be_t(m__io, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/bcd_user_type_be.cpp.o] Error 1
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_mod.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_enum.cpp:20:49: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_opcodes->push_back(std::move(std::unique_ptr(new opcode_t(m__io, this, m__root))));
                                           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_enum.cpp:41:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new intval_t(m__io, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_enum.cpp:46:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new strval_t(m__io, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_enum.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_exception.cpp:21:46: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_docs->push_back(std::move(std::unique_ptr(new doc_t(m__io, this, m__root))));
                                        ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_exception.cpp:39:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_main = std::unique_ptr(new main_obj_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_exception.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_vs_value_inst.cpp:17:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_child = std::unique_ptr(new child_obj_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_vs_value_inst.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_circular_a.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new imports_circular_b_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_circular_a.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_else.cpp:20:48: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_chunks->push_back(std::move(std::unique_ptr(new chunk_t(m__io, this, m__root))));
                                          ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_else.cpp:43:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new chunk_meta_t(m__io__raw_body, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_else.cpp:49:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new chunk_dir_t(m__io__raw_body, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_else.cpp:55:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new dummy_t(m__io__raw_body, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size_else.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_complex.cpp:23:22: error: cannot refer to class template 'unique_ptr' without a template argument list
            _ = std::unique_ptr(new type_u1_t(m__io, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_complex.cpp:33:22: error: cannot refer to class template 'unique_ptr' without a template argument list
            _ = std::unique_ptr(new type_u2_t(m__io, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_complex.cpp:3:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory:63:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h:46:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h:33:
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h:120:23: error: call to deleted constructor of 'std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> >'
        { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                             ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:254:8: note: in instantiation of function template specialization '__gnu_cxx::new_allocator<std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> > >::construct<std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> >, const std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> > &>' requested here
        { __a.construct(__p, std::forward<_Args>(__args)...); }
              ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:393:4: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> > > >::_S_construct<std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> >, const std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> > &>' requested here
        { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
          ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h:905:21: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> > > >::construct<std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> >, const std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> > &>' requested here
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                           ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_complex.cpp:24:22: note: in instantiation of member function 'std::vector<std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> >, std::allocator<std::unique_ptr<repeat_until_complex_t::type_u1_t, std::default_delete<repeat_until_complex_t::type_u1_t> > > >::push_back' requested here
            m_first->push_back(_);
                     ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:273:7: note: 'unique_ptr' has been explicitly marked deleted here
      unique_ptr(const unique_ptr&) = delete;
      ^
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_complex.cpp:3:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory:63:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h:46:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h:33:
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h:120:23: error: call to deleted constructor of 'std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> >'
        { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                             ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:254:8: note: in instantiation of function template specialization '__gnu_cxx::new_allocator<std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> > >::construct<std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> >, const std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> > &>' requested here
        { __a.construct(__p, std::forward<_Args>(__args)...); }
              ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:393:4: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> > > >::_S_construct<std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> >, const std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> > &>' requested here
        { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
          ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h:905:21: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> > > >::construct<std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> >, const std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> > &>' requested here
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                           ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_complex.cpp:34:23: note: in instantiation of member function 'std::vector<std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> >, std::allocator<std::unique_ptr<repeat_until_complex_t::type_u2_t, std::default_delete<repeat_until_complex_t::type_u2_t> > > >::push_back' requested here
            m_second->push_back(_);
                      ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:273:7: note: 'unique_ptr' has been explicitly marked deleted here
      unique_ptr(const unique_ptr&) = delete;
      ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/type_ternary_opaque.cpp:27:30: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_dif_wo_hack = std::unique_ptr(new term_strz_t(m__io__raw_dif_wo_hack));
                        ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/type_ternary_opaque.cpp:35:32: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_dif_with_hack = std::unique_ptr(new term_strz_t(m__io__raw_dif_with_hack));
                          ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_complex.cpp.o] Error 1
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/type_ternary_opaque.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_bytes.cpp:20:45: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_records->push_back(std::move(std::unique_ptr(new record_t(m__io, this, m__root))));
                                       ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_bytes.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/yaml_ints.cpp:43:21: warning: implicit conversion from 'unsigned long long' to 'int32_t' (aka 'int') changes value from 18446744073709551615 to -1 [-Wconstant-conversion]
    m_test_u8_dec = 18446744073709551615ULL;
                  ~ ^~~~~~~~~~~~~~~~~~~~~~~
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/yaml_ints.cpp:51:21: warning: implicit conversion from 'unsigned long long' to 'int32_t' (aka 'int') changes value from 18446744073709551615 to -1 [-Wconstant-conversion]
    m_test_u8_hex = 18446744073709551615ULL;
                  ~ ^~~~~~~~~~~~~~~~~~~~~~~
2 warnings generated.
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/str_encodings_default.cpp:18:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_rest = std::unique_ptr(new subtype_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/str_encodings_default.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_io_pos.cpp:21:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_substream1 = std::unique_ptr(new all_plus_number_t(m__io__raw_substream1, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_io_pos.cpp:24:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_substream2 = std::unique_ptr(new all_plus_number_t(m__io__raw_substream2, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_io_pos.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types3.cpp:18:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_a_cc = std::unique_ptr(new subtype_a_t::subtype_cc_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types3.cpp:19:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_a_c_d = std::unique_ptr(new subtype_a_t::subtype_c_t::subtype_d_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types3.cpp:20:16: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_b = std::unique_ptr(new subtype_b_t(m__io, this, m__root));
          ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types3.cpp:86:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_a_cc = std::unique_ptr(new subtype_a_t::subtype_cc_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types3.cpp:87:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_a_c_d = std::unique_ptr(new subtype_a_t::subtype_c_t::subtype_d_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
5 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types3.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/index_to_param_expr.cpp:28:44: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_blocks->push_back(std::move(std::unique_ptr(new block_t(i, m__io, this, m__root))));
                                      ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/index_to_param_expr.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/debug_enum_name.cpp:23:24: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_test_type = std::unique_ptr(new test_subtype_t(m__io, this, m__root));
                  ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/debug_enum_name.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers2.cpp:4:
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers2.h:55:40: error: member reference base type 'const uint64_t' (aka 'const unsigned long') is not a structure or union
    uint64_t len() const { return m_len.get(); }
                                  ~~~~~^~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers2.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_circular_b.cpp:21:27: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_back_ref = std::unique_ptr(new imports_circular_a_t(m__io));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_circular_b.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers.cpp:4:
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers.h:54:46: error: member reference base type 'const uint64_t' (aka 'const unsigned long') is not a structure or union
        uint64_t body() const { return m_body.get(); }
                                       ~~~~~~^~~~
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers.cpp:20:49: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_opcodes->push_back(std::move(std::unique_ptr(new opcode_t(m__io, this, m__root))));
                                           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_usertype2.cpp:20:45: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_records->push_back(std::move(std::unique_ptr(new record_t(m__io, this, m__root))));
                                       ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_usertype2.cpp:42:29: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_buf_unproc = std::unique_ptr(new foo_t(m__io, this, m__root));
                       ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_usertype2.cpp:50:27: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_buf_proc = std::unique_ptr(new foo_t(m__io__raw_buf_proc, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_usertype2.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_external_type.cpp:17:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_one = std::unique_ptr(new term_strz_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_external_type.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name.cpp:17:24: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_main_data = std::unique_ptr(new main_t(m__io, this, m__root));
                  ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name.cpp:18:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_dummy = std::unique_ptr(new dummy_obj_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name.cpp:33:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_foo = std::unique_ptr(new foo_obj_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_same_name.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent2.cpp:22:42: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_tags->push_back(std::move(std::unique_ptr(new tag_t(m__io, this, m__root))));
                                    ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent2.cpp:71:34: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_tag_content = std::unique_ptr(new tag_char_t(io, this, m__root));
                            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_rel_1.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new imported_1_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent2.cpp.o] Error 1
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_rel_1.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent.cpp:17:21: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_header = std::unique_ptr(new header_obj_t(m__io, this, m__root));
               ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent.cpp:18:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_index = std::unique_ptr(new index_obj_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_abs_abs.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new imported_and_abs_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent.cpp:51:45: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_entries->push_back(std::move(std::unique_ptr(new entry_t(m__io, this, m__root))));
                                       ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_abs_abs.cpp.o] Error 1
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_is_be.cpp:21:46: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_docs->push_back(std::move(std::unique_ptr(new doc_t(m__io, this, m__root))));
                                        ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_is_be.cpp:39:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_main = std::unique_ptr(new main_obj_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_is_be.cpp:144:27: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_inst_sub = std::unique_ptr(new sub_main_obj_t(m__io, this, m__root, m__is_le));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_is_be.cpp:146:27: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_inst_sub = std::unique_ptr(new sub_main_obj_t(m__io, this, m__root, m__is_le));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_is_be.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_usertype.cpp:17:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_first = std::unique_ptr(new block_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_usertype.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_one = std::unique_ptr(new param_type_t(first(), m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_usertype.cpp:18:33: error: no matching constructor for initialization of 'params_pass_usertype_t::param_type_t'
    m_one = std::unique_ptr(new param_type_t(first(), m__io, this, m__root));
                                ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_usertype.h:55:9: note: candidate constructor not viable: no known conversion from 'params_pass_usertype_t::block_t *' to 'std::unique_ptr<block_t>' for 1st argument
        param_type_t(std::unique_ptr<block_t> p_foo, kaitai::kstream* p__io, params_pass_usertype_t* p__parent = nullptr, params_pass_usertype_t* p__root = nullptr);
        ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_usertype.h:51:11: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 4 were provided
    class param_type_t : public kaitai::kstruct {
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_usertype.cpp:40:11: error: overload resolution selected deleted operator '='
    m_foo = p_foo;
    ~~~~~ ^ ~~~~~
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:274:19: note: candidate function has been explicitly deleted
      unique_ptr& operator=(const unique_ptr&) = delete;
                  ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:190:7: note: candidate function not viable: no known conversion from 'std::unique_ptr<block_t>' to 'std::unique_ptr<params_pass_usertype_t::block_t, std::default_delete<params_pass_usertype_t::block_t> > &&' for 1st argument
      operator=(unique_ptr&& __u) noexcept
      ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:203:2: note: candidate function [with _Up = params_pass_usertype_t::block_t, _Ep = std::default_delete<params_pass_usertype_t::block_t>] not viable: no known conversion from 'std::unique_ptr<block_t>' to 'unique_ptr<params_pass_usertype_t::block_t, std::default_delete<params_pass_usertype_t::block_t> > &&' for 1st argument
        operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
        ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:211:7: note: candidate function not viable: no known conversion from 'std::unique_ptr<block_t>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str.cpp:20:49: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_opcodes->push_back(std::move(std::unique_ptr(new opcode_t(m__io, this, m__root))));
                                           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str.cpp:42:27: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body = std::unique_ptr(new intval_t(m__io, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str.cpp:46:27: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body = std::unique_ptr(new strval_t(m__io, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_pass_usertype.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/non_standard.cpp:4:
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/non_standard.h:54:40: error: member reference base type 'const uint32_t' (aka 'const unsigned int') is not a structure or union
    uint32_t bar() const { return m_bar.get(); }
                                  ~~~~~^~~~
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str.cpp.o] Error 1
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/non_standard.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/if_struct.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_op1 = std::unique_ptr(new operation_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/if_struct.cpp:19:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_op2 = std::unique_ptr(new operation_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/if_struct.cpp:20:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_op3 = std::unique_ptr(new operation_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/if_struct.cpp:39:28: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_arg_tuple = std::unique_ptr(new arg_tuple_t(m__io, this, m__root));
                      ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/if_struct.cpp:44:26: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_arg_str = std::unique_ptr(new arg_str_t(m__io, this, m__root));
                    ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
5 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/if_struct.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/recursive_one.cpp:20:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_next = std::unique_ptr(new recursive_one_t(m__io));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/recursive_one.cpp:25:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_next = std::unique_ptr(new recursive_one_t(m__io));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/recursive_one.cpp:30:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_next = std::unique_ptr(new recursive_one_t(m__io));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/recursive_one.cpp:35:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_next = std::unique_ptr(new fini_t(m__io, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_to_user.cpp:20:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_buf1 = std::unique_ptr(new just_str_t(m__io__raw_buf1, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/recursive_one.cpp.o] Error 1
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_to_user.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_enum.cpp:17:32: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_invoke_with_param = std::unique_ptr(new with_param_t(one(), m__io, this, m__root));
                          ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/if_values.cpp:20:43: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_codes->push_back(std::move(std::unique_ptr(new code_t(m__io, this, m__root))));
                                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/params_enum.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/vlq_base128_le.cpp:23:22: error: cannot refer to class template 'unique_ptr' without a template argument list
            _ = std::unique_ptr(new group_t(m__io, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/vlq_base128_le.cpp:75:335: warning: shift count >= width of type [-Wshift-count-overflow]
    m_value = (((((((groups()->at(0)->value() + ((len() >= 2) ? ((groups()->at(1)->value() << 7)) : (0))) + ((len() >= 3) ? ((groups()->at(2)->value() << 14)) : (0))) + ((len() >= 4) ? ((groups()->at(3)->value() << 21)) : (0))) + ((len() >= 5) ? ((groups()->at(4)->value() << 28)) : (0))) + ((len() >= 6) ? ((groups()->at(5)->value() << 35)) : (0))) + ((len() >= 7) ? ((groups()->at(6)->value() << 42)) : (0))) + ((len() >= 8) ? ((groups()->at(7)->value() << 49)) : (0)));
                                                                                                                                                                                                                                                                                                                                              ^  ~~
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/vlq_base128_le.cpp:75:396: warning: shift count >= width of type [-Wshift-count-overflow]
    m_value = (((((((groups()->at(0)->value() + ((len() >= 2) ? ((groups()->at(1)->value() << 7)) : (0))) + ((len() >= 3) ? ((groups()->at(2)->value() << 14)) : (0))) + ((len() >= 4) ? ((groups()->at(3)->value() << 21)) : (0))) + ((len() >= 5) ? ((groups()->at(4)->value() << 28)) : (0))) + ((len() >= 6) ? ((groups()->at(5)->value() << 35)) : (0))) + ((len() >= 7) ? ((groups()->at(6)->value() << 42)) : (0))) + ((len() >= 8) ? ((groups()->at(7)->value() << 49)) : (0)));
                                                                                                                                                                                                                                                                                                                                                                                                           ^  ~~
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/vlq_base128_le.cpp:75:457: warning: shift count >= width of type [-Wshift-count-overflow]
    m_value = (((((((groups()->at(0)->value() + ((len() >= 2) ? ((groups()->at(1)->value() << 7)) : (0))) + ((len() >= 3) ? ((groups()->at(2)->value() << 14)) : (0))) + ((len() >= 4) ? ((groups()->at(3)->value() << 21)) : (0))) + ((len() >= 5) ? ((groups()->at(4)->value() << 28)) : (0))) + ((len() >= 6) ? ((groups()->at(5)->value() << 35)) : (0))) + ((len() >= 7) ? ((groups()->at(6)->value() << 42)) : (0))) + ((len() >= 8) ? ((groups()->at(7)->value() << 49)) : (0)));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^  ~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/if_values.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/vlq_base128_le.cpp:3:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory:63:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h:46:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h:33:
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h:120:23: error: call to deleted constructor of 'std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> >'
        { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                             ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:254:8: note: in instantiation of function template specialization '__gnu_cxx::new_allocator<std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> > >::construct<std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> >, const std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> > &>' requested here
        { __a.construct(__p, std::forward<_Args>(__args)...); }
              ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:393:4: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> > > >::_S_construct<std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> >, const std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> > &>' requested here
        { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
          ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h:905:21: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> > > >::construct<std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> >, const std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> > &>' requested here
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                           ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/vlq_base128_le.cpp:24:23: note: in instantiation of member function 'std::vector<std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> >, std::allocator<std::unique_ptr<vlq_base128_le_t::group_t, std::default_delete<vlq_base128_le_t::group_t> > > >::push_back' requested here
            m_groups->push_back(_);
                      ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:273:7: note: 'unique_ptr' has been explicitly marked deleted here
      unique_ptr(const unique_ptr&) = delete;
      ^
3 warnings and 2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/vlq_base128_le.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/debug_array_user.cpp:16:22: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_one_cat = std::unique_ptr(new cat_t(m__io, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/debug_array_user.cpp:22:56: error: cannot refer to class template 'unique_ptr' without a template argument list
        std::unique_ptr<cat_t> _t_array_of_cats = std::unique_ptr(new cat_t(m__io, this, m__root));
                                                  ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_override.cpp:18:22: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_child_1 = std::unique_ptr(new child_t(m__io, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_override.cpp:19:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_mediator_2 = std::unique_ptr(new mediator_t(m__io, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_override.cpp:33:22: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_child_2 = std::unique_ptr(new child_t(m__io, _parent(), m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_override.cpp.o] Error 1
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/debug_array_user.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imported_1.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new imported_2_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int.cpp:20:49: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_opcodes->push_back(std::move(std::unique_ptr(new opcode_t(m__io, this, m__root))));
                                           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int.cpp:41:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new intval_t(m__io, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int.cpp:46:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new strval_t(m__io, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imported_1.cpp.o] Error 1
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_bytearray.cpp:20:49: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_opcodes->push_back(std::move(std::unique_ptr(new opcode_t(m__io, this, m__root))));
                                           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports0.cpp:19:17: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_hw = std::unique_ptr(new hello_world_t(m__io));
           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_bytearray.cpp:42:27: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body = std::unique_ptr(new intval_t(m__io, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_bytearray.cpp:46:27: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body = std::unique_ptr(new strval_t(m__io, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports0.cpp.o] Error 1
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_bytearray.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/position_abs.cpp:43:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_index = std::unique_ptr(new index_obj_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/position_abs.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_false.cpp:18:24: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_element_a = std::unique_ptr(new parent_a_t(m__io, this, m__root));
                  ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_false.cpp:19:24: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_element_b = std::unique_ptr(new parent_b_t(m__io, this, m__root));
                  ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_false.cpp:34:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_foo = std::unique_ptr(new child_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_false.cpp:35:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_bar = std::unique_ptr(new parent_b_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_false.cpp:49:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_foo = std::unique_ptr(new child_t(m__io, nullptr, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imported_and_abs.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new imported_root_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imported_and_abs.cpp.o] Error 1
5 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_false.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/type_ternary.cpp:27:30: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_dif_wo_hack = std::unique_ptr(new dummy_t(m__io__raw_dif_wo_hack, this, m__root));
                        ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/type_ternary.cpp:32:28: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_dif_with_hack = std::unique_ptr(new dummy_t(m__io__raw_dif_with_hack, this, m__root));
                      ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/type_ternary.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_sized.cpp:29:22: error: cannot refer to class template 'unique_ptr' without a template argument list
            _ = std::unique_ptr(new record_t(io__raw_records, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_sized.cpp:3:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory:63:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h:46:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h:33:
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h:120:23: error: call to deleted constructor of 'std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> >'
        { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                             ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:254:8: note: in instantiation of function template specialization '__gnu_cxx::new_allocator<std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> > >::construct<std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> >, const std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> > &>' requested here
        { __a.construct(__p, std::forward<_Args>(__args)...); }
              ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:393:4: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> > > >::_S_construct<std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> >, const std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> > &>' requested here
        { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
          ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h:905:21: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> > > >::construct<std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> >, const std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> > &>' requested here
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                           ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_sized.cpp:30:24: note: in instantiation of member function 'std::vector<std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> >, std::allocator<std::unique_ptr<repeat_until_sized_t::record_t, std::default_delete<repeat_until_sized_t::record_t> > > >::push_back' requested here
            m_records->push_back(_);
                       ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:273:7: note: 'unique_ptr' has been explicitly marked deleted here
      unique_ptr(const unique_ptr&) = delete;
      ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/repeat_until_sized.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/position_in_seq.cpp:49:21: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_header = std::unique_ptr(new header_obj_t(m__io, this, m__root));
               ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/position_in_seq.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_usertype1.cpp:20:45: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_records->push_back(std::move(std::unique_ptr(new record_t(m__io, this, m__root))));
                                       ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_usertype1.cpp:45:29: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_buf_unproc = std::unique_ptr(new foo_t(m__io__raw_buf_unproc, this, m__root));
                       ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_usertype1.cpp:53:27: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_buf_proc = std::unique_ptr(new foo_t(m__io__raw_buf_proc, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/process_coerce_usertype1.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_abs_rel.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new imported_and_rel_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_abs_rel.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp:17:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_one = std::unique_ptr(new subtype_a_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new subtype_b_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp:34:28: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_typed_at_root = std::unique_ptr(new subtype_b_t(m__io, this, m__root));
                      ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp:35:26: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_typed_here1 = std::unique_ptr(new subtype_c_t(m__io, this, m__root));
                    ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp:36:26: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_typed_here2 = std::unique_ptr(new subtype_cc_t(m__io, this, m__root));
                    ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp:53:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_typed_here = std::unique_ptr(new subtype_d_t(m__io, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp:54:27: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_typed_parent = std::unique_ptr(new subtype_cc_t(m__io, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp:55:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_typed_root = std::unique_ptr(new subtype_b_t(m__io, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
8 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types2.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_switch.cpp:20:26: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_content = std::unique_ptr(new element_1_t(m__io, this, m__root));
                    ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_switch.cpp:40:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_subelement = std::unique_ptr(new subelement_1_t(m__io, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent_switch.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_inherited.cpp:21:46: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_docs->push_back(std::move(std::unique_ptr(new doc_t(m__io, this, m__root))));
                                        ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_inherited.cpp:39:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_main = std::unique_ptr(new main_obj_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_inherited.cpp:74:22: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_insides = std::unique_ptr(new sub_obj_t(m__io, this, m__root, m__is_le));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_inherited.cpp:78:22: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_insides = std::unique_ptr(new sub_obj_t(m__io, this, m__root, m__is_le));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_inherited.cpp:105:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_more = std::unique_ptr(new subsub_obj_t(m__io, this, m__root, m__is_le));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_inherited.cpp:110:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_more = std::unique_ptr(new subsub_obj_t(m__io, this, m__root, m__is_le));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types.cpp:17:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_one = std::unique_ptr(new subtype_a_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_two = std::unique_ptr(new subtype_b_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types.cpp:33:28: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_typed_at_root = std::unique_ptr(new subtype_b_t(m__io, this, m__root));
                      ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types.cpp:34:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_typed_here = std::unique_ptr(new subtype_c_t(m__io, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
6 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/default_endian_expr_inherited.cpp.o] Error 1
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nested_types.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_repeat_expr.cpp:35:46: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body->push_back(std::move(std::unique_ptr(new one_t(io__raw_body, this, m__root))));
                                        ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_repeat_expr.cpp:43:46: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body->push_back(std::move(std::unique_ptr(new two_t(io__raw_body, this, m__root))));
                                        ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_repeat_expr.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_else.cpp:20:49: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_opcodes->push_back(std::move(std::unique_ptr(new opcode_t(m__io, this, m__root))));
                                           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_else.cpp:39:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new intval_t(m__io, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_else.cpp:43:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new strval_t(m__io, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_else.cpp:47:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new noneval_t(m__io, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_else.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_with_param.cpp:17:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_one = std::unique_ptr(new params_def_t(5, true, m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_with_param.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/index_to_param_until.cpp:29:22: error: cannot refer to class template 'unique_ptr' without a template argument list
            _ = std::unique_ptr(new block_t(i, m__io, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/index_to_param_until.cpp:3:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory:63:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h:46:
In file included from /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h:33:
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h:120:23: error: call to deleted constructor of 'std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> >'
        { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                             ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:254:8: note: in instantiation of function template specialization '__gnu_cxx::new_allocator<std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> > >::construct<std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> >, const std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> > &>' requested here
        { __a.construct(__p, std::forward<_Args>(__args)...); }
              ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h:393:4: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> > > >::_S_construct<std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> >, const std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> > &>' requested here
        { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
          ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h:905:21: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> > > >::construct<std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> >, const std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> > &>' requested here
            _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                           ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/index_to_param_until.cpp:30:23: note: in instantiation of member function 'std::vector<std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> >, std::allocator<std::unique_ptr<index_to_param_until_t::block_t, std::default_delete<index_to_param_until_t::block_t> > > >::push_back' requested here
            m_blocks->push_back(_);
                      ^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:273:7: note: 'unique_ptr' has been explicitly marked deleted here
      unique_ptr(const unique_ptr&) = delete;
      ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/index_to_param_until.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/index_to_param_eos.cpp:28:48: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_blocks->push_back(std::move(std::unique_ptr(new block_t(i, m__io, this, m__root))));
                                          ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/index_to_param_eos.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size.cpp:20:48: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_chunks->push_back(std::move(std::unique_ptr(new chunk_t(m__io, this, m__root))));
                                          ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent3.cpp:68:34: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_tag_content = std::unique_ptr(new tag_char_t(io, this, m__root));
                            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size.cpp:45:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new chunk_meta_t(m__io__raw_body, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size.cpp:52:23: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_body = std::unique_ptr(new chunk_dir_t(m__io__raw_body, this, m__root));
                 ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent3.cpp:85:42: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_tags->push_back(std::move(std::unique_ptr(new tag_t(m__io, this, m__root))));
                                    ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
3 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_int_size.cpp.o] Error 1
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/nav_parent3.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_io_eof.cpp:21:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_substream1 = std::unique_ptr(new one_or_two_t(m__io__raw_substream1, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_io_eof.cpp:24:25: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_substream2 = std::unique_ptr(new one_or_two_t(m__io__raw_substream2, this, m__root));
                   ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/expr_io_eof.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/position_to_end.cpp:43:20: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_index = std::unique_ptr(new index_obj_t(m__io, this, m__root));
              ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/position_to_end.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str_else.cpp:20:49: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_opcodes->push_back(std::move(std::unique_ptr(new opcode_t(m__io, this, m__root))));
                                           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str_else.cpp:40:27: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body = std::unique_ptr(new intval_t(m__io, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str_else.cpp:43:27: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body = std::unique_ptr(new strval_t(m__io, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str_else.cpp:46:27: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_body = std::unique_ptr(new noneval_t(m__io, this, m__root));
                     ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
4 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_manual_str_else.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/user_type.cpp:16:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_one = std::unique_ptr(new header_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_if.cpp:18:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_op1 = std::unique_ptr(new operation_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_if.cpp:19:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_op2 = std::unique_ptr(new operation_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_if.cpp:20:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_op3 = std::unique_ptr(new operation_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_if.cpp:39:28: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_arg_tuple = std::unique_ptr(new arg_tuple_t(m__io, this, m__root));
                      ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_if.cpp:44:26: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_arg_str = std::unique_ptr(new arg_str_t(m__io, this, m__root));
                    ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/user_type.cpp.o] Error 1
5 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_if.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_external_type_02_child.cpp:19:17: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_s3 = std::unique_ptr(new opaque_external_type_02_child_child_t(m__io, this, m__root));
           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/opaque_external_type_02_child.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/instance_io_user.cpp:23:45: error: cannot refer to class template 'unique_ptr' without a template argument list
        m_entries->push_back(std::move(std::unique_ptr(new entry_t(m__io, this, m__root))));
                                       ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/instance_io_user.cpp:27:22: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_strings = std::unique_ptr(new strings_obj_t(m__io__raw_strings, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/instance_io_user.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_abs.cpp:17:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_len = std::unique_ptr(new vlq_base128_le_t(m__io));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/imports_abs.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_1.cpp:16:19: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_main = std::unique_ptr(new main_obj_t(m__io, this, m__root));
             ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_1.cpp:30:22: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_submain = std::unique_ptr(new submain_obj_t(m__io, this, m__root));
                ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/enum_1.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/fixed_struct.cpp:68:18: error: cannot refer to class template 'unique_ptr' without a template argument list
    m_hdr = std::unique_ptr(new header_t(m__io, this, m__root));
            ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/fixed_struct.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_multi_bool_ops.cpp:4:
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_multi_bool_ops.h:54:46: error: member reference base type 'const uint64_t' (aka 'const unsigned long') is not a structure or union
        uint64_t body() const { return m_body.get(); }
                                       ~~~~~~^~~~
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_multi_bool_ops.cpp:20:49: error: cannot refer to class template 'unique_ptr' without a template argument list
            m_opcodes->push_back(std::move(std::unique_ptr(new opcode_t(m__io, this, m__root))));
                                           ~~~~~^
/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h:109:11: note: template is declared here
    class unique_ptr
          ^
2 errors generated.
make[2]: *** [CMakeFiles/ks_tests.dir/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_multi_bool_ops.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_cast_nested.cpp:4:10: fatal error: 'cast_nested.h' file not found
#include <cast_nested.h>
         ^~~~~~~~~~~~~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_cast_nested.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_non_standard.cpp:4:
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/non_standard.h:54:40: error: member reference base type 'const uint32_t' (aka 'const unsigned int') is not a structure or union
    uint32_t bar() const { return m_bar.get(); }
                                  ~~~~~^~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_non_standard.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_switch_integers.cpp:4:
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers.h:54:46: error: member reference base type 'const uint64_t' (aka 'const unsigned long') is not a structure or union
        uint64_t body() const { return m_body.get(); }
                                       ~~~~~~^~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_switch_integers.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_switch_integers2.cpp:4:
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_integers2.h:55:40: error: member reference base type 'const uint64_t' (aka 'const unsigned long') is not a structure or union
    uint64_t len() const { return m_len.get(); }
                                  ~~~~~^~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_switch_integers2.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_switch_cast.cpp:3:10: fatal error: 'switch_cast.h' file not found
#include <switch_cast.h>
         ^~~~~~~~~~~~~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_switch_cast.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_switch_repeat_expr.cpp:16:24: error: cannot cast from type '__gnu_cxx::__alloc_traits<std::allocator<std::unique_ptr<kaitai::kstruct, std::default_delete<kaitai::kstruct> > > >::value_type' (aka 'std::unique_ptr<kaitai::kstruct, std::default_delete<kaitai::kstruct> >') to pointer type 'switch_repeat_expr_t::one_t *'
    BOOST_CHECK_EQUAL((static_cast<switch_repeat_expr_t::one_t*>(r->body()->at(0)))->first(), std::string("Stuff\0Me\0", 9));
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/boost/test/test_tools.hpp:169:109: note: expanded from macro 'BOOST_CHECK_EQUAL'
    BOOST_CHECK_WITH_ARGS_IMPL( ::boost::test_tools::tt_detail::equal_impl_frwd(), "", CHECK, CHECK_EQUAL, (L)(R) )
                                                                                                            ^
/usr/include/boost/test/test_tools.hpp:103:59: note: expanded from macro 'BOOST_CHECK_WITH_ARGS_IMPL'
    BOOST_PP_SEQ_FOR_EACH( BOOST_TEST_PASS_ARG_INFO, '_', ARGS ) ); \
                                                          ^~~~
/usr/include/boost/preprocessor/seq/for_each.hpp:26:80: note: expanded from macro 'BOOST_PP_SEQ_FOR_EACH'
#    define BOOST_PP_SEQ_FOR_EACH(macro, data, seq) BOOST_PP_FOR((macro, data, seq (nil)), BOOST_PP_SEQ_FOR_EACH_P, BOOST_PP_SEQ_FOR_EACH_O, BOOST_PP_SEQ_FOR_EACH_M)
                                                                               ^~~
note: (skipping 10 expansions in backtrace; use -fmacro-backtrace-limit=0 to see all)
/usr/include/boost/preprocessor/seq/elem.hpp:43:60: note: expanded from macro 'BOOST_PP_SEQ_ELEM_II'
#    define BOOST_PP_SEQ_ELEM_II(im) BOOST_PP_SEQ_ELEM_III(im)
                                                           ^~
/usr/include/boost/preprocessor/seq/elem.hpp:44:41: note: expanded from macro 'BOOST_PP_SEQ_ELEM_III'
#    define BOOST_PP_SEQ_ELEM_III(x, _) x
                                        ^
/usr/include/boost/test/test_tools.hpp:97:52: note: expanded from macro 'BOOST_TEST_PASS_ARG_INFO'
#define BOOST_TEST_PASS_ARG_INFO( r, data, arg ) , arg, BOOST_STRINGIZE( arg )
                                                   ^~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_switch_repeat_expr.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_cast_to_imported.cpp:3:10: fatal error: 'cast_to_imported.h' file not found
#include <cast_to_imported.h>
         ^~~~~~~~~~~~~~~~~~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_cast_to_imported.cpp.o] Error 1
In file included from /home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_switch_multi_bool_ops.cpp:3:
/home/travis/build/kaitai-io/ci_targets/tests/compiled/cpp_stl_11/switch_multi_bool_ops.h:54:46: error: member reference base type 'const uint64_t' (aka 'const unsigned long') is not a structure or union
        uint64_t body() const { return m_body.get(); }
                                       ~~~~~~^~~~
/home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_process_coerce_switch.cpp:4:10: fatal error: 'process_coerce_switch.h' file not found
#include <process_coerce_switch.h>
         ^~~~~~~~~~~~~~~~~~~~~~~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_process_coerce_switch.cpp.o] Error 1
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_switch_multi_bool_ops.cpp.o] Error 1
/home/travis/build/kaitai-io/ci_targets/tests/spec/cpp_stl_11/test_cast_to_top.cpp:4:10: fatal error: 'cast_to_top.h' file not found
#include <cast_to_top.h>
         ^~~~~~~~~~~~~~~
1 error generated.
make[2]: *** [CMakeFiles/ks_tests.dir/test_cast_to_top.cpp.o] Error 1
make[2]: Target `CMakeFiles/ks_tests.dir/build' not remade because of errors.
make[1]: *** [CMakeFiles/ks_tests.dir/all] Error 2
make[1]: Target `all' not remade because of errors.
make: *** [all] Error 2
make: Target `default_target' not remade because of errors.
